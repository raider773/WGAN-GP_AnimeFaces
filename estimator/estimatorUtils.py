import pickle
import tensorflow as tf
import numpy as np
import keras.backend as K
from utils.utils import create_folder

class Save_model(tf.keras.callbacks.Callback):    
    """Saves weights and optimizers of critic and generator with the given frecuency"""
    def __init__(self,save_frecuency,path):        
        self.save_frecuency = save_frecuency
        self.path = path + "/model"
        
        create_folder(self.path)        
        
    def on_epoch_end(self, epoch, logs=None):
        if epoch % self.save_frecuency == 0:
            
            print("Saving weights")
            
            create_folder(f"{self.path}/epoch_{epoch}")          
            
            self.model.generator.save_weights(f"{self.path}/epoch_{epoch}/generator_weights.hdf5")
            self.model.critic.save_weights(f"{self.path}/epoch_{epoch}/critic_weights.hdf5")                     
            
            print("Saving optimizer weights")   
            
            output_file_generator = f"{self.path}/epoch_{epoch}/generator_optimizer.npy"
            output_file_critic = f"{self.path}/epoch_{epoch}/critic_optimizer.npy"
            
            np.save(output_file_generator, self.model.generator_optimizer.get_weights())
            np.save(output_file_critic, self.model.critic_optimizer.get_weights())   
            

class Save_images(tf.keras.callbacks.Callback):    
    """Saves numpy arrays generated by generator with the given frecuency"""
    def __init__(self,save_frecuency,path,amount_of_images):        
        self.save_frecuency = save_frecuency               
        self.amount_of_images = amount_of_images         
        self.path = path + "/images"   
                          
        create_folder(self.path)
                          
        
    def on_epoch_end(self, epoch, logs=None):
        if epoch % self.save_frecuency == 0:
            
            create_folder(f"{self.path}/epoch_{epoch}")               
                          
            print("Generating vector")
            vector = np.random.normal(size=(self.amount_of_images, self.model.z_dim)) 
            print("Generating image")
            images = self.model.generator.predict(vector) 
            print("Saving image")
            np.save(f"{self.path}/epoch_{epoch}/images", images)
            

def lr_schedule(epoch, lr):  
    """Staricase learning rate schduler. Reduce learning rate every 10 epochs"""
    if epoch == 0:
        return lr    
    elif epoch % 50 == 0:
        return lr * 0.1
    else: 
        return lr    
    
    
class LearningRateScheduler(tf.keras.callbacks.Callback):   
    """Learning rate scheduler callback. Applies different schedulers to critic and generator optimizers"""
    def __init__(self, generator_schedule, critic_schedule):
        super(LearningRateScheduler, self).__init__()
        
        self.generator_schedule = generator_schedule
        self.critic_schedule = critic_schedule       

    def on_epoch_begin(self, epoch, logs=None):
        if not hasattr(self.model.optimizer, "lr"):
            raise ValueError('Optimizer must have a "lr" attribute.')
            
        generator_lr = float(tf.keras.backend.get_value(self.model.generator_optimizer.learning_rate))
        critic_lr = float(tf.keras.backend.get_value(self.model.critic_optimizer.learning_rate))
        
        generator_new_lr = self.generator_schedule(epoch, generator_lr)
        critic_new_lr = self.critic_schedule(epoch, critic_lr)
       
        tf.keras.backend.set_value(self.model.generator_optimizer.lr, generator_new_lr)
        tf.keras.backend.set_value(self.model.critic_optimizer.lr, critic_new_lr)
            
        print(f"Generator lr in epoch {epoch} is {generator_new_lr}")
        print(f"Critic lr in epoch {epoch} is {critic_new_lr}")